import numpy as np
import pyopencl as cl
from random import randint
from StringIO import StringIO



class Location:
    """
    Represents 2D coordinates within the grid area.-
    """
    x = None
    y = None

    def __init__ (self, x, y):
        self.x = int (x)
        self.y = int (y)



class UE:
    """
    Represents one user equipment (i.e. mobile device),
    part of a Montecarlo snapshot.-
    """
    #
    # UE location whithin the grid
    #
    location = None
    #
    # UE Tx power (in dBm * 100)
    #
    tx_pwr = 2100

    def move (self, height, width):
        """
        Randomly positions this UE within the area of the received shape.-
        """
        self.location = Location (randint (1, height) - 1,
                                  randint (1, width) - 1)



class Montecarlo:
    """
    Represents one Montecarlo snapshot of UEs within the grid area.-
    """
    #
    # the grid area size within which the Montecarlo simulation should run
    #
    grid_height = None
    grid_width = None
    #
    # a list of UEs contained in this montecarlo simulation
    #
    ue_list = None

    def __init__ (self, ue_count, grid_height, grid_width):
        """
        Creates a new Montecarlo simulation, containing 'ue_count' UEs,
        within the received grid shape.-
        """
        self.grid_height = np.uintc (grid_height)
        self.grid_width = np.uintc (grid_width)
        self.ue_list = list ( )
        for i in range (0, int (ue_count)):
            self.ue_list.append (UE ( ))
            self.ue_list[-1].move (self.grid_height,
                                   self.grid_width)

    def randomize (self):
        """
        Creates a random snapshot of this Montecarlo simulation.-
        """
        for ue in self.ue_list:
            ue.move (self.grid_height, self.grid_width)



class Cell:
    """
    Represents a cell within the area being optimized.-
    """
    #
    # cell name and ID
    #
    name = None
    #
    # the pilot power of this cell (in dBm)
    #
    pilot_pwr = None
    # 
    # the loss generated by the cable from the antenna to the Node B (in dBm)
    #
    cable_loss = None
    #
    # whether there is ASC amplifier present in this cell
    #
    has_asc = False
    #
    # a numpy array containing the DL path losses of this cell,
    # and its corresponding OpenCL buffer
    #
    DL_path_loss_matrix = None
    DL_path_loss_matrix_gpu = None
    #
    # a numpy array containing the UL path losses of this cell
    # and its corresponding OpenCL buffer
    #
    UL_path_loss_matrix = None
    UL_path_loss_matrix_gpu = None

    def _read_matrix (self, file_name):
        """
        Reads matrix data from 'file_name', saving everything in 'matrix'.-
        """
        with open (file_name, 'r') as f:
            #
            # save the entire file here, as list of lines
            #
            input_lines = f.readlines ( )
        f.close ( )
        #
        # fist line contains number of matrix columns
        #
        col_count = input_lines[0].split ('  ')
        assert (col_count[0] == 'NCOLS')
        col_count = int(col_count[1])
        #
        # second line contains number of matrix rows
        #
        row_count = input_lines[1].split ('  ')
        assert (row_count[0] == 'NROWS')
        row_count = int(row_count[1])
        #
        # sixth line contains the 'NO DATA' value
        #
        no_data = input_lines[5].split ('  ')
        assert (no_data[0] == 'NODATA_VALUE')
        no_data = int(no_data[1])
        #
        # from the seventh line on, the data is included
        #
        matrix = np.genfromtxt (StringIO (''.join (input_lines[6:])), 
                                delimiter=' ',
                                dtype=np.single)
        assert ((row_count, col_count) == matrix.shape)
        matrix = np.reshape (matrix, row_count * col_count)
        #
        # data is given in 100s of units
        #
        hundreds = [100] * (row_count * col_count)
        hundreds = np.asarray (hundreds, dtype=np.single)
        matrix = np.true_divide (matrix, hundreds)
        return matrix

    def __init__ (self, ocl_context):
        """
        Creates a new cell object, associating it with the 
        received OpenCL context.-
        """
        self.ctx = ocl_context

    def read_DL_path_loss_data (self, file_name):
        """
        Reads the DL path loss data from 'file_name', generating
        a numpy matrix at member 'DL_path_loss_matrix', and its
        OCL buffer.-
        """
        mf = cl.mem_flags
        self.DL_path_loss_matrix = self._read_matrix (file_name)
        self.DL_path_loss_matrix_gpu = cl.Buffer (self.ctx, 
                                                  mf.READ_ONLY | mf.COPY_HOST_PTR, 
                                                  hostbuf=self.DL_path_loss_matrix)

    def read_UL_path_loss_data (self, file_name):
        """
        Reads the UL path loss data from 'file_name', generating
        a numpy matrix at member 'UL_path_loss_matrix', and its
        OCL buffer.-
        """
        mf = cl.mem_flags
        self.UL_path_loss_matrix = self._read_matrix (file_name)
        self.UL_path_loss_matrix_gpu = cl.Buffer (self.ctx, 
                                                  mf.READ_ONLY | mf.COPY_HOST_PTR, 
                                                  hostbuf=self.UL_path_loss_matrix)

